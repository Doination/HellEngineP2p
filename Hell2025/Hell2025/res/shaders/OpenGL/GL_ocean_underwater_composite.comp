#version 430 core
#include "../common/constants.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D LightingImage; // output
layout (binding = 1) uniform sampler2D UnderwaterMaskTexture;
layout (binding = 2) uniform sampler2D GaussianFinalLighting;
layout (binding = 3) uniform sampler2D WaterColorTexture;
layout (binding = 4) uniform sampler2D WorldPositionTexture;
layout (binding = 5) uniform sampler2D NormalsTexture;
layout (binding = 6) uniform sampler2D WaterWorldPositionTexture;
layout (binding = 7) uniform sampler2D WaterDUDVTexture;
layout (binding = 8) uniform sampler3D OceanTexture3D;

uniform float u_time;
uniform vec3 u_viewPos;
uniform vec3 u_cameraForward;
uniform mat4 u_inverseProjectionView;
uniform vec2 u_resolution;

//const float distortionSpeed = 0.05;
//const float distortionFactor = 0.002;
//const float waterUVScaling = 0.5;

vec3 IntersectRayWithGroundPlane(vec3 rayOrigin, vec3 rayDir, float groundHeight) {
    float t = (groundHeight - rayOrigin.y) / rayDir.y;
    return rayOrigin + rayDir * t;
}

vec3 GetWorldRay(vec2 fragCoord, vec2 resolution, mat4 inverseProjectionView, vec3 viewPos) {
    vec2 ndc = (fragCoord / resolution) * 2.0 - 1.0;
    vec4 clip = vec4(ndc, 1.0, 1.0);
    vec4 world = inverseProjectionView * clip;
    world /= world.w;
    return normalize(world.xyz - viewPos);
}

vec3 ApplyFog(vec3 inputColor, float viewDistance, float startDistance, float endDistance, float exponent, vec3 fogColor) {
    float fogRange = endDistance - startDistance;
    // Calculate distance normalized to the fog range [0, 1]
    float normDist = (viewDistance - startDistance) / max(fogRange, 0.0001);
    // Clamp the normalized distance
    normDist = clamp(normDist, 0.0, 1.0);
    // Apply exponent for the fog curve. This factor goes from 0 (no fog) to 1 (full fog).
    float fogEffect = pow(normDist, exponent);
    // Blend from inputColor towards fogColor based on the fogEffect factor
    // mix(original, target, factor)
    return mix(inputColor, fogColor, fogEffect);
}

vec3 ApplyDepthFog(vec3 sceneColor, float depth, vec3 fogColor, float fogStart, float fogEnd) {
    float fogFactor = clamp((depth - fogStart) / (fogEnd - fogStart), 0.0, 1.0);
    return mix(sceneColor, fogColor, fogFactor);
}


void main2() {
ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);   
    ivec2 outputImageSize = imageSize(LightingImage);
    vec2 uv_screenspace = (vec2(pixelCoords) + 0.5) / vec2(outputImageSize);

    // Don't process out of bounds pixels
    if (pixelCoords.x >= outputImageSize.x || pixelCoords.y >= outputImageSize.y) {
        return;
    }    
    
    vec4 lighting = imageLoad(LightingImage, pixelCoords);
    vec3 gaussianFinalLighting = texture(GaussianFinalLighting, uv_screenspace).rgb;
    float underwaterMask = texture(UnderwaterMaskTexture, uv_screenspace).r;
    vec3 waterColor = texture(WaterColorTexture, uv_screenspace).rgb;
    vec3 worldPos = texture(WorldPositionTexture, uv_screenspace).xyz;
    vec3 waterWorldPos = texture(WaterWorldPositionTexture, uv_screenspace).xyz;
    vec3 Normal = texture(NormalsTexture, uv_screenspace).xyz;

    const float distortionSpeed = 0.05;
    const float distortionFactor = 0.0024;
    const float waterUVScaling = 0.55;

        float offsetX = mod(u_time * distortionSpeed, 1.0);
        
        vec2 uv_dudv = vec2(uv_screenspace + vec2(offsetX, 0));

        vec2 distortion = texture(WaterDUDVTexture, uv_dudv).rg * 2 - 1;
        vec2 uv_refraction = uv_screenspace + (distortion * distortionFactor);
        uv_refraction = clamp(uv_refraction, 0, 1);

        vec3 distortedFinalLighting = texture(GaussianFinalLighting, uv_refraction).rgb;

       // vec3 finalColor = distortedFinalLighting;
       // imageStore(LightingImage, pixelCoords, vec4(vec3(finalColor), 1.0));

        vec3 finalColor = (distortedFinalLighting * UNDER_WATER_TINT * 4);
        finalColor += waterColor;

        
      //float viewDistance = distance(u_viewPos, worldPos);
      //
      //float startDistance;
      //float endDistance;
      //float exponent;
      //vec3 fogColor;
      //
      //startDistance = 5;
      //endDistance = 15;
      //exponent = 1;
      //fogColor = vec3(0.1, 0.25, 0.3) * 0.2;
      //fogColor = vec3(0.35, 0.35, 0.3) * 0.2;
      //vec3 nearFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);        
      //finalColor = mix(finalColor, nearFog, 0.9);
      //
      //nearFog = ApplyFog(waterColor, viewDistance, startDistance, endDistance, exponent, fogColor);    
      /// waterColor = mix(waterColor, nearFog, 0.5);
      //
      //startDistance = 5;
      //endDistance = 40;
      //exponent = 1;
      //fogColor = vec3(0.1, 0.5, 0.3) * 0.2;;//vec3(0.05, 0.1, 0.2) * 0.2;
      //vec3 distantFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);  
      //finalColor = mix(finalColor, distantFog, 0.75);
      //
      ////waterColor = ApplyFog(waterColor, viewDistance, startDistance, endDistance, exponent, fogColor);
      //
      //vec3 yolo = (distortedFinalLighting * UNDER_WATER_TINT) ;//+ waterColor;
      //
      //
      //
      //
      //finalColor = mix(finalColor, yolo, 0.85);
      //
      //finalColor += waterColor;
      //
      //
      //float depth = worldPos.y;
      //vec3 depthFogColor = vec3(0.02, 0.025, 0.03) * 0.95; // cold black-blue, like deep ocean
      ////depthFogColor = vec3(1, 0, 0); // cold black-blue, like deep ocean
      //float depthFogStart = -1;
      //float depthFogEnd = -5;
      //
      //// Depth fog
      //finalColor = ApplyDepthFog(finalColor, depth, depthFogColor, depthFogStart, depthFogEnd);
      //
      //









       // finalColor = mix(finalColor, distantFog, 0.9);
        
       // finalColor = distantFog;
       // finalColor = nearFog;


    //finalColor = distortedFinalLighting;

    //finalColor.r = 0;
    
    vec3 rayDir = GetWorldRay(pixelCoords, u_resolution, u_inverseProjectionView, u_viewPos);
    float sampleDist = 5.0;
    vec3 samplePos = u_viewPos + rayDir * sampleDist;

    float waterHeight = -0.65;
    //float yDepthScale = 2;

    ivec3 volumeSize = textureSize(OceanTexture3D, 0);

    vec3 volumeOrigin = vec3(
        u_viewPos.x - volumeSize.x / 2.0f,
        waterHeight - volumeSize.y,
        u_viewPos.z - volumeSize.z / 2.0f
    );

    vec3 localPos = samplePos - volumeOrigin;
    
    // Water surface 
    if (waterWorldPos != vec3(0,0,0)) {
        localPos = waterWorldPos - volumeOrigin;
    }
    // Regular geometry
    else if (Normal != vec3(0,0,0)) {
        localPos = worldPos - volumeOrigin;
    }
        //localPos = waterWorldPos - volumeOrigin;

    //localPos.y *= yDepthScale;
    vec3 uvw = clamp(localPos / volumeSize, 0.0, 1.0);

    vec3 fogColor = texture(OceanTexture3D, uvw).rgb;
    float noise = fract(sin(dot(pixelCoords + u_time, vec2(12.9898,78.233))) * 43758.5453);
    //float noise = fract(sin(dot(pixelCoords, vec2(12.9898,78.233))) * 43758.5453);
    float ditherStrength = 1.0 / 255.0;
    ditherStrength *= 2;

   
    fogColor += (noise - 0.5) * ditherStrength;
    
    
    bool skyBox = Normal == vec3(0,0,0) && waterWorldPos == vec3(0,0,0);
    bool regularGeometry = Normal != vec3(0,0,0) && waterWorldPos == vec3(0,0,0);

    // If you aren't the water surface...
    
    // Regular geometry
    if (regularGeometry) {
        float viewDistance = distance(u_viewPos, worldPos);
        float startDistance = 10;
        float endDistance = 35;
        float exponent = 2;
        vec3 fogColor = vec3(0.4, 0.8, 0.6) * 0.035; // volume fill pass was * 0.35
        vec3 distantFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);  
        finalColor = mix(finalColor, distantFog, 0.95);
    }
     // Skybox pixels
    else if (skyBox) {       
        finalColor = fogColor * 5 * fogColor;
//        finalColor *= 0.5;    
        finalColor += waterColor;
    }   
    // Water surface
    else {            
        float viewDistance = distance(u_viewPos, waterWorldPos);
        float startDistance = 10;
        float endDistance = 35;
        float exponent = 1.0;
        vec3 fogColor = vec3(0.4, 0.8, 0.6) * 0.045; // volume fill pass was * 0.35
        vec3 distantFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);  
        finalColor = mix(finalColor, distantFog, 0.95);

        
        vec3 rayDir = normalize(u_cameraForward);
        float rayDistance = length(waterWorldPos - u_viewPos);
        vec3 samplePos = u_viewPos + rayDir * rayDistance;
        vec3 localPos = samplePos - volumeOrigin;
        vec3 uvw = clamp(localPos / volumeSize, 0.0, 1.0);
        vec3 sampledFogColor = texture(OceanTexture3D, uvw).rgb;
        //finalColor = sampledFogColor;
    }
    
           // finalColor += waterColor;
            //
    //finalColor = Normal;

   // finalColor = vec3(pos.x / size.x, pos.y / size.y, pos.z / size.z);//uvw;

     vec3 down = vec3(0.0, -1.0, 0.0);
    float downwardness = dot(rayDir, down); // 1 when looking straight down, 0 when horizontal, -1 when straight up
    downwardness = clamp(downwardness, 0.0, 1.0); // clamp anything above horizon to 1.0
    float darkness = mix(1.0, 0.0, downwardness); // fades from 1.0 (bright) to 0.0 (black) as you look down
    vec3 finalFog = fogColor * darkness;

    finalColor = vec3(0.4, 0.8, 0.6) * darkness * 0.1;
    finalColor += (noise - 0.5) * ditherStrength;

    if (underwaterMask < 0.75 && underwaterMask > 0.25) {

        imageStore(LightingImage, pixelCoords, vec4(finalColor, 1.0));
   }
  
   // imageStore(LightingImage, pixelCoords, vec4(vec3(worldPos.y), 1.0));


   // }
}















void main() {
ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);   
    ivec2 outputImageSize = imageSize(LightingImage);
    vec2 uv_screenspace = (vec2(pixelCoords) + 0.5) / vec2(outputImageSize);

    // Don't process out of bounds pixels
    if (pixelCoords.x >= outputImageSize.x || pixelCoords.y >= outputImageSize.y) {
        return;
    }    
    
    vec4 lighting = imageLoad(LightingImage, pixelCoords);
    vec3 gaussianFinalLighting = texture(GaussianFinalLighting, uv_screenspace).rgb;
    float underwaterMask = texture(UnderwaterMaskTexture, uv_screenspace).r;
    vec3 waterColor = texture(WaterColorTexture, uv_screenspace).rgb;
    vec3 worldPos = texture(WorldPositionTexture, uv_screenspace).xyz;
    vec3 waterWorldPos = texture(WaterWorldPositionTexture, uv_screenspace).xyz;
    vec3 Normal = texture(NormalsTexture, uv_screenspace).xyz;

    const float distortionSpeed = 0.05;
    const float distortionFactor = 0.0024;
    const float waterUVScaling = 0.55;

        float offsetX = mod(u_time * distortionSpeed, 1.0);
        
        vec2 uv_dudv = vec2(uv_screenspace + vec2(offsetX, 0));

        vec2 distortion = texture(WaterDUDVTexture, uv_dudv).rg * 2 - 1;
        vec2 uv_refraction = uv_screenspace + (distortion * distortionFactor);
        uv_refraction = clamp(uv_refraction, 0, 1);

        vec3 distortedFinalLighting = texture(GaussianFinalLighting, uv_refraction).rgb;

       // vec3 finalColor = distortedFinalLighting;
       // imageStore(LightingImage, pixelCoords, vec4(vec3(finalColor), 1.0));

        vec3 finalColor = (distortedFinalLighting * UNDER_WATER_TINT * 4);
        finalColor += waterColor;

        
      //float viewDistance = distance(u_viewPos, worldPos);
      //
      //float startDistance;
      //float endDistance;
      //float exponent;
      //vec3 fogColor;
      //
      //startDistance = 5;
      //endDistance = 15;
      //exponent = 1;
      //fogColor = vec3(0.1, 0.25, 0.3) * 0.2;
      //fogColor = vec3(0.35, 0.35, 0.3) * 0.2;
      //vec3 nearFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);        
      //finalColor = mix(finalColor, nearFog, 0.9);
      //
      //nearFog = ApplyFog(waterColor, viewDistance, startDistance, endDistance, exponent, fogColor);    
      /// waterColor = mix(waterColor, nearFog, 0.5);
      //
      //startDistance = 5;
      //endDistance = 40;
      //exponent = 1;
      //fogColor = vec3(0.1, 0.5, 0.3) * 0.2;;//vec3(0.05, 0.1, 0.2) * 0.2;
      //vec3 distantFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);  
      //finalColor = mix(finalColor, distantFog, 0.75);
      //
      ////waterColor = ApplyFog(waterColor, viewDistance, startDistance, endDistance, exponent, fogColor);
      //
      //vec3 yolo = (distortedFinalLighting * UNDER_WATER_TINT) ;//+ waterColor;
      //
      //
      //
      //
      //finalColor = mix(finalColor, yolo, 0.85);
      //
      //finalColor += waterColor;
      //
      //
      //float depth = worldPos.y;
      //vec3 depthFogColor = vec3(0.02, 0.025, 0.03) * 0.95; // cold black-blue, like deep ocean
      ////depthFogColor = vec3(1, 0, 0); // cold black-blue, like deep ocean
      //float depthFogStart = -1;
      //float depthFogEnd = -5;
      //
      //// Depth fog
      //finalColor = ApplyDepthFog(finalColor, depth, depthFogColor, depthFogStart, depthFogEnd);
      //
      //









       // finalColor = mix(finalColor, distantFog, 0.9);
        
       // finalColor = distantFog;
       // finalColor = nearFog;


    //finalColor = distortedFinalLighting;

    //finalColor.r = 0;
    
    vec3 rayDir = GetWorldRay(pixelCoords, u_resolution, u_inverseProjectionView, u_viewPos);
    float sampleDist = 5.0;
    vec3 samplePos = u_viewPos + rayDir * sampleDist;

    float waterHeight = -0.65;
    //float yDepthScale = 2;

    ivec3 volumeSize = textureSize(OceanTexture3D, 0);

    vec3 volumeOrigin = vec3(
        u_viewPos.x - volumeSize.x / 2.0f,
        waterHeight - volumeSize.y,
        u_viewPos.z - volumeSize.z / 2.0f
    );

    vec3 localPos = samplePos - volumeOrigin;
    
    // Water surface 
    if (waterWorldPos != vec3(0,0,0)) {
        localPos = waterWorldPos - volumeOrigin;
    }
    // Regular geometry
    else if (Normal != vec3(0,0,0)) {
        localPos = worldPos - volumeOrigin;
    }
        //localPos = waterWorldPos - volumeOrigin;

    //localPos.y *= yDepthScale;
    vec3 uvw = clamp(localPos / volumeSize, 0.0, 1.0);

    vec3 fogColor = texture(OceanTexture3D, uvw).rgb;
    float noise = fract(sin(dot(pixelCoords + u_time, vec2(12.9898,78.233))) * 43758.5453);
    //float noise = fract(sin(dot(pixelCoords, vec2(12.9898,78.233))) * 43758.5453);
    float ditherStrength = 1.0 / 255.0;
    ditherStrength *= 2;

   
    fogColor += (noise - 0.5) * ditherStrength;
    
    bool skyBox = Normal == vec3(0,0,0) && waterWorldPos == vec3(0,0,0);
    bool regularGeometry = Normal != vec3(0,0,0) && waterWorldPos == vec3(0,0,0);

    // Camera Ray fog
    vec3 down = vec3(0.0, -1.0, 0.0);
    float downwardness = clamp(dot(rayDir, down), 0.0, 1.0); // 0 = flat, 1 = straight down
    float darknessCurve = 0.85;
    float darkness = mix(1.0, 0.0, pow(downwardness, darknessCurve)); // blend to black as you look down
    vec3 finalRayFog = vec3(0.4, 0.8, 0.6) * darkness * 0.05;
    finalRayFog += (noise - 0.5) * ditherStrength;

    
    // Regular geometry
    if (regularGeometry) {
        float viewDistance = distance(u_viewPos, worldPos);
        float startDistance = 10;
        float endDistance = 35;
        float exponent = 2;
        vec3 fogColor = vec3(0.4, 0.8, 0.6) * 0.035; // volume fill pass was * 0.35
        vec3 distantFog = ApplyFog(finalColor, viewDistance, startDistance, endDistance, exponent, fogColor);  
        finalColor = mix(finalColor, distantFog, 0.95);
    }
     // Skybox pixels
    else if (skyBox) {       
        finalColor = fogColor * 5 * fogColor;
        finalColor += waterColor;
        finalColor = finalRayFog;
    }   
    // Water surface
    else {
        float waterSurfaceDistance = distance(u_viewPos, waterWorldPos);
        float maxDist = 70.0; // Max distance at which full blend occurs
        float exponent = 0.19;
        float t = clamp(waterSurfaceDistance / maxDist, 0.0, 1.0);
        float blendFactor = pow(t, exponent);
        finalColor = mix(finalColor, finalRayFog, blendFactor);
    }
    
    // Depth darkness
    float depthStart = -2.0;
    float depthEnd   = -20.0;
    float depthExponent = 1.5;
    float maxDarkness = 0.65; 

    // Distance into the depths
    float depth = clamp((depthStart - u_viewPos.y) / (depthStart - depthEnd), 0.0, 1.0);
    float curvedDepth = pow(depth, depthExponent);
    float depthDarknessFactor = mix(1.0, maxDarkness, curvedDepth);
    finalColor *= depthDarknessFactor;

    // Write color if fragment is underwater
    if (underwaterMask < 0.75 && underwaterMask > 0.25) {
        imageStore(LightingImage, pixelCoords, vec4(finalColor, 1.0));
    }
}