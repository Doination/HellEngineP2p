#version 450

#ifndef ENABLE_BINDLESS
    #define ENABLE_BINDLESS 1
#endif

#if ENABLE_BINDLESS == 1
    #extension GL_ARB_bindless_texture : enable
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#if ENABLE_BINDLESS == 1
    readonly restrict layout(std430, binding = 0) buffer textureSamplersBuffer {
	    uvec2 textureSamplers[];
    };

#else
    layout (binding = 4) uniform sampler2D DecalTex0;
    layout (binding = 5) uniform sampler2D DecalTex1;
    layout (binding = 6) uniform sampler2D DecalTex2;
    layout (binding = 7) uniform sampler2D DecalTex3;
#endif

layout(rgba8, binding = 0) uniform image2D GBufferBaseColorImage;
layout(rgba8, binding = 1) uniform image2D GBufferRMAImage;
layout (binding = 2) uniform sampler2D WorldPositionTexture;
layout (binding = 3) uniform sampler2D GBufferNormalTexture;

struct ScreenSpaceDecal {
    mat4 modelMatrix;
    mat4 inverseModelMatrix;
    int type;
    int textureIndex;
    int padding1;
    int padding2;
};

readonly restrict layout(std430, binding = 12) buffer ScreenSpaceDecalBuffer { ScreenSpaceDecal screenSpaceDecals[]; };

uniform mat4 u_projectionView;
uniform int u_decalCount;

/*
#ifndef ENABLE_BINDLESS

void main() {
    // RENDER DOC FRIENDLY MAIN FUNCTION
}

#else
*/
void main() {
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);   
    ivec2 size = imageSize(GBufferBaseColorImage);
    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) return;
    
    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(size);

    // Do nothing on walls
    vec3 normal = texture(GBufferNormalTexture, uv).rgb;
    float angleToFloor = abs(normal.y);
    float floorFade    = step(0.5, angleToFloor);
    if (floorFade <= 0.0) {
        //imageStore(GBufferBaseColorImage, pixelCoords, vec4(0.0));
        return;
    }

    // Blocking mask
    vec4 rma = imageLoad(GBufferRMAImage, pixelCoords);
    if (rma.a == 0) {
        return;
    }

    vec3 worldPos = texture(WorldPositionTexture, uv).rgb;
    vec3 baseColor = imageLoad(GBufferBaseColorImage, pixelCoords).rgb;

    float bestMask = 0.0;
    for (int i = 0; i < u_decalCount; ++i) {
        vec4 objPos = screenSpaceDecals[i].inverseModelMatrix * vec4(worldPos, 1.0);
        vec3 dist = vec3(0.5) - abs(objPos.xyz);
        
        // Multiply by a factor to steepen the falloff (tweak 1000 for higher/sharper, lower for softer)
        float fx = clamp(dist.x * 1000.0, 0.0, 1.0);
        float fy = clamp(dist.y * 1000.0, 0.0, 1.0);
        float fz = clamp(dist.z * 1000.0, 0.0, 1.0);
        float cubeFade = fx * fy * fz;

        // Skip if completely outside
        if (cubeFade <= 0.0) continue;

        int textureIndex = screenSpaceDecals[i].textureIndex;
        vec2 texCoords = clamp(objPos.xz + 0.5, 0.0, 1.0);
        vec4 texData = texture(sampler2D(textureSamplers[textureIndex]), texCoords);
        float a = texData.a;

        bestMask = max(bestMask, a);

        // No need to check more decals if the mask is full
        if (bestMask >= 1.0) {
            break;
        }
    }
    
    vec3 bloodBase = vec3(0.2, 0.0, 0.0);
    vec3 bloodRMA  = vec3(0.125, 0.15, 1.0);

    vec3 outBase = mix(baseColor, bloodBase, bestMask);
    vec3 outRMA  = mix(rma.rgb,    bloodRMA,  bestMask);

    imageStore(GBufferBaseColorImage, pixelCoords, vec4(outBase, 1.0));
    imageStore(GBufferRMAImage, pixelCoords, vec4(outRMA,  1.0));
}
//#endif