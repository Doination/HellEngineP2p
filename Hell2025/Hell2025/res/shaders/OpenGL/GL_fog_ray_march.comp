#version 460
#include "../common/lighting.glsl"
#include "../common/types.glsl"
#include "../common/util.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout (binding = 1) uniform sampler2D uDepth;
layout (binding = 2) uniform sampler3D uNoiseVol;
layout (binding = 3) uniform usampler2D ViewportIndexTexture;
layout (binding = 4, rgba16f) uniform image2D OutputFogImage;

readonly restrict layout(std430, binding = 2) buffer viewportDataBuffer { ViewportData viewportData[]; };

uniform int u_noiseSeed;

uniform bool u_isSplitscreen;

uniform float u_time;

const vec3 fogSpeed = vec3(0.10, 0.02, 0.10);
vec3 fogColor = vec3(0.222, 0.233, 0.260) * 0.5325;

const float MAX_FOG_DIST = 30.0;      
const int NUM_STEPS = 48;     

const float nearFadeAmbient = 1.0;
const float farFadeAmbient = MAX_FOG_DIST;

const float nearFadeFlashlight = 0.5;
const float farFadeFlashlight = 5;

const float noiseScaleXZ = 1.0 / 8.0; // repeat every x metres and x == (1 / y)
const float noiseScaleY = 1.0 / 6.0; // repeat every x metres and x == (1 / y)


float dt = MAX_FOG_DIST / float(NUM_STEPS); 

// Random sampling functions
uint seed = 0u;

void hash(){
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
}

float random(){
    hash();
    return float(seed)/4294967295.0;
}

void main() {
    ivec2 px   = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(OutputFogImage);
    if (px.x >= resolution.x || px.y >= resolution.y) return;

    vec2 uv_screenspace = (vec2(px) + 0.5) / vec2(resolution);
        
    uint viewportIndex = texture(ViewportIndexTexture, uv_screenspace).r;

    mat4 projection = viewportData[viewportIndex].projection; 
    mat4 view = viewportData[viewportIndex].view;  
    mat4 invViewProj = inverse(projection * view);
    vec3 viewPos = viewportData[viewportIndex].viewPos.xyz;

    invViewProj = viewportData[viewportIndex].inverseProjectionView;

    float depth = texture(uDepth, uv_screenspace).r;
    
    // THIS WAS HOW YOU WERE DOING IT. FIND OUT FOR SURE IF THIS IS NOT ACTUALLY CORRECT
    // THIS WAS HOW YOU WERE DOING IT. FIND OUT FOR SURE IF THIS IS NOT ACTUALLY CORRECT
    // THIS WAS HOW YOU WERE DOING IT. FIND OUT FOR SURE IF THIS IS NOT ACTUALLY CORRECT
    //vec4 clip = vec4(uv_screenspace * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    // THIS WAS HOW YOU WERE DOING IT. FIND OUT FOR SURE IF THIS IS NOT ACTUALLY CORRECT
    // THIS WAS HOW YOU WERE DOING IT. FIND OUT FOR SURE IF THIS IS NOT ACTUALLY CORRECT
    // THIS WAS HOW YOU WERE DOING IT. FIND OUT FOR SURE IF THIS IS NOT ACTUALLY CORRECT

    vec4 clip = vec4(uv_screenspace * 2.0 - 1.0, depth, 1.0);

    if (u_isSplitscreen) {
        if (viewportIndex == 0) {
            clip = vec4(vec2(uv_screenspace.x * 2.0 - 1.0, ((uv_screenspace.y * 2 - 1) * 2.0 - 1.0) ), depth, 1.0);
        }
        if (viewportIndex == 1) {
            clip = vec4(vec2(uv_screenspace.x * 2.0 - 1.0, ((uv_screenspace.y * 2 - 0) * 2.0 - 1.0) ), depth, 1.0);
        }
    }

    vec4 viewH = invViewProj * clip;
    viewH.xyz /= viewH.w;
    vec3 origin= viewPos;
    vec3 dir = normalize(viewH.xyz - viewPos);
    
    float sceneDist = length(viewH.xyz - viewPos);

    float t = 0.0;
    vec3 accCol = vec3(0.0);
    float accAlpha = 0.0;

    ivec3 texSize = textureSize(uNoiseVol, 0);
    int fogTextureSize = texSize.x;
    
    // Offset starting distance (to hide banding)
    seed = uint(px.y * resolution.x + px.x) + uint(u_noiseSeed) * uint(px.x) * uint(px.y);
    float rand = random();
    float t0 = rand * dt;
    
    const float timeScrollSpeed = 2;
    const float xMorphSpeed = 5.0;
    const float zMorphSpeed = 5.0;
    const float yScrollSpeed = 1;

    float timeScroll = fract(u_time * timeScrollSpeed / float(fogTextureSize));
    float xMorph = fract(u_time * xMorphSpeed / float(fogTextureSize));
    float zMorph = fract(u_time * zMorphSpeed / float(fogTextureSize));
    float yScroll = fract(u_time * yScrollSpeed / float(fogTextureSize));

    for (int i = 0; i < NUM_STEPS + 0; ++i) {
        float t = dt * float(i) + t0;

        if(t >= sceneDist) break; 

        vec3 raySampleWorldPos = origin + dir * t;
        vec3 dynamicOffset = fogSpeed * u_time;
        
        vec3 uvScale = vec3(noiseScaleXZ, noiseScaleY, noiseScaleXZ);
        vec3 baseUV = fract((raySampleWorldPos + dynamicOffset) * uvScale);
        vec3 nuv1 = baseUV;
        nuv1.x = fract(nuv1.x - xMorph + 0.1 + timeScroll);
        nuv1.z = fract(nuv1.z + zMorph + 0.1 + timeScroll);
        nuv1.y = fract(nuv1.y + yScroll);
        float d1 = texture(uNoiseVol, nuv1).r;

        vec3 nuv2 = baseUV;
        nuv2.x = fract(nuv2.x + xMorph);
        nuv2.z = fract(nuv2.z - zMorph);
        nuv2.y = fract(nuv1.y - yScroll);
        float d2 = texture(uNoiseVol, nuv2).r;

        float dens = mix(d1, d2, 0.5);
        float ext = exp(-dens * dt);

        // Fade in the fog
        float fadeAmbient = clamp( (t - nearFadeAmbient) / (farFadeAmbient - nearFadeAmbient), 0.0, 1.0 );
        float fadeFlashlight = clamp( (t - nearFadeFlashlight) / (farFadeFlashlight - nearFadeFlashlight), 0.0, 1.0 );
        
        // Ambient fog
        vec3 ambientFogColor = vec3(dens * dt * fadeAmbient);






        // Flashlight term
        int flashlightPlayerIndex = 0;
        vec3 flashlightPosition = viewportData[flashlightPlayerIndex].flashlightPosition.xyz ;//+ (cameraForward * 2);        

        vec3 flashlightColor = vec3(0.9, 0.95, 1.1);
        vec3 flashLightDir = viewportData[flashlightPlayerIndex].flashlightDir.xyz;

        float flashlightModifer = viewportData[flashlightPlayerIndex].flashlightModifer;
        float flashlightRadius = 10.0;
        float flashlightStrength = 0.5;

        float innerAngle = cos(radians(5.0 * flashlightModifer));
        float outerAngle = cos(radians(25.0));         

        vec3 d = flashlightPosition - raySampleWorldPos;
        float dist = length(d);
        vec3 toLight = d / dist;
        vec3 viewDir = normalize(viewPos - raySampleWorldPos);
    
        // distance fall-off + strength
        float lightAttenuation = smoothstep(flashlightRadius, 0.0, dist) * flashlightStrength;
    
        // cone fall-off
        float spotFactor = smoothstep(outerAngle, innerAngle, dot(toLight, -flashLightDir));
    
        // extra smooth fade by distance
        float distanceFactor = clamp(1.0 - dist / flashlightRadius, 0.0, 1.0);
        spotFactor *= distanceFactor * distanceFactor;
    
        // Lambert
        float irradiance = lightAttenuation * spotFactor;        
        vec3 flashlightLighting = spotFactor * lightAttenuation * fadeFlashlight * flashlightModifer * flashlightColor;
                
        // Total in scattering at this step
        float fogStrength = 0.5;
        vec3 insc = (ambientFogColor + flashlightLighting) * fogStrength; 

        // front-to-back composite
        accCol += (1.0 - accAlpha) * insc;
        accAlpha += (1.0 - accAlpha) * (1.0 - ext);
        t += dt;

        if (accAlpha >= 0.99) break;
    }
    
    // Factor in fog color
    accCol *= fogColor;

    // Tone it down a bit
    //accCol *= 0.325;

    //accCol *= 20;
    
    // Store it
    imageStore(OutputFogImage, px, vec4(accCol, accAlpha));
}
